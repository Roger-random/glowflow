//////////////////////////////////////////////////////////////////////////////
//
// Accelerometer Tilt 3D
//
// A Pixelblaze pattern to illuminate half of a 3D mapped volume based on value of
// accelerometer on the Pixelblaze sensor expansion board. Renders illusion of a
// half-full container of glowing fluid that flows to the bottom.
//
// Requires:
// * Pixelblaze with sensor expansion board
// * Pixel Mapper filled in with 3D (X,Y,Z) coordinates of LED pixels
//
// To use as starting point for other accelerometer-reactive 3D Pixelblaze projects:
// * In beforeRender(), modify accelerometer readings so that its X,Y,Z values
//   are aligned with physical X,Y,Z of LEDs as described in Pixel Mapper.
// * At the end of render3D(), use the accelerometer-transformed X/Y/Z values
//   in tx3D[] array to set color as desired.
//
// Roger Cheng 2019
// https://newscrewdriver.com
// Github: Roger-random / Twitter: @Regorlas

// Accelerometer value will be filled in by Pixelblaze when sensor board is present
export var accelerometer

// Matrix for transform to rotate about Y axis
var rotYm = array(16)

// Matrix for transform to rotate about Z axis
var rotZm = array(16)

// Coordinate for matrix transform calculations
var tx3D = array(4)

// Before rendering each frame, take an accelerometer reading and convert to spherical coordinates
// https://en.wikipedia.org/wiki/List_of_common_coordinate_transformations#From_Cartesian_coordinates_2
export function beforeRender(delta) {
  // How far the accelerometer vector has tilted relative to +Z axis in spherical coordinates.
  // 0 = vector is pointing up, aligned with +Z
  // PI = vector is pointing down, aligned with -Z
  var accelPolar

  // Which direction the accelerometer vector is tilted in spherical coordinates
  // 0 = vector is aligned with +X
  // PI/2 = vector is aligned with +Y
  // -PI/2 = vector is aligned with -Y
  var accelAzimuth

  // Take snapshot of accelerometer
  a = accelerometer

  // Adjust axis to fit mechanical chassis
  a[0] = -a[0] // X axis is mounted reversed

  // Calculate polar angle
  if (a[2] == 0) {
    // Z = 0 means acceleration vector is somewhere on XY plane.
    // Hard code answer is faster and avoids divide by zero.
    accelPolar = PI/2
  } else if (a[2] > 0) {
    // +Z = between 0 and PI/2
    accelPolar = atan(sqrt(pow(a[0],2)+pow(a[1],2))/a[2])
  } else {
    // -Z = between PI/2 and PI
    accelPolar = PI-atan(sqrt(pow(a[0],2)+pow(a[1],2))/-a[2])
  }

  // Calculate azimuth angle
  if (a[0] == 0) {
    // X of zero means acceleration vector is aligned with Y axis one way or another.
    // Hard code answer is faster and avoids divide by zero
    if (a[1] >= 0) {
      // Aligned with +Y axis
      accelAzimuth = PI/2
    } else {
      // Aligned with -Y axis
      accelAzimuth = -PI/2
    }
  } else if (a[0] > 0) {
    // +X = somewhere between -PI/2 and PI/2
    accelAzimuth = atan(a[1]/a[0])
  } else {
    // -X = somewhere between PI and PI/2 for +Y, between -PI and -PI/2 for -Y
    accelAzimuth = PI-atan(a[1]/-a[0])
  }

  setRotateAboutYAxis(accelPolar)
  setRotateAboutZAxis(accelAzimuth)
}

// 3D transform matrix math adapted from
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web
function setRotateAboutYAxis(angle) {
  rotYm[0]=cos(angle); rotYm[1]  = 0;  rotYm[2]=sin(angle); rotYm[3]  = 0
  rotYm[4]  = 0;       rotYm[5]  = 1;  rotYm[6]  = 0;       rotYm[7]  = 0
  rotYm[8]=-sin(angle);rotYm[9]  = 0;  rotYm[10]=cos(angle);rotYm[11] = 0
  rotYm[12] = 0;       rotYm[13] = 0;  rotYm[14] = 0;       rotYm[15] = 1
}

function rotateAboutY() {
  // Make a copy of point coordinates as they change during multiplication
  var x = tx3D[0];
  var y = tx3D[1];
  var z = tx3D[2];
  var w = tx3D[3];

  /* General form
  tx3D[0] = (x * rotYm[ 0]) + (y * rotYm[ 4]) + (z * rotYm[ 8]) + (w * rotYm[12]);
  tx3D[1] = (x * rotYm[ 1]) + (y * rotYm[ 5]) + (z * rotYm[ 9]) + (w * rotYm[13]);
  tx3D[2] = (x * rotYm[ 2]) + (y * rotYm[ 6]) + (z * rotYm[10]) + (w * rotYm[14]);
  tx3D[3] = (x * rotYm[ 3]) + (y * rotYm[ 7]) + (z * rotYm[11]) + (w * rotYm[15]);
  */

  // Optimized form: multiply just the nonzero parts of setRotateAboutYAxis
  tx3D[0] = (x * rotYm[ 0])                   + (z * rotYm[ 8])                  ;
  tx3D[1] =                    y                                                 ;
  tx3D[2] = (x * rotYm[ 2])                   + (z * rotYm[10])                  ;
  tx3D[3] =                                                        w             ;
}

function setRotateAboutZAxis(angle) {
  rotZm[0]=cos(angle);rotZm[1]=-sin(angle);rotZm[2]  = 0;  rotZm[3]  = 0
  rotZm[4]=sin(angle);rotZm[5]=cos(angle); rotZm[6]  = 0;  rotZm[7]  = 0
  rotZm[8]  = 0;      rotZm[9]  = 0;       rotZm[10] = 1;  rotZm[11] = 0
  rotZm[12] = 0;      rotZm[13] = 0;       rotZm[14] = 0;  rotZm[15] = 1
}

function rotateAboutZ() {
  // Make a copy of point coordinates as they change during multiplication
  var x = tx3D[0];
  var y = tx3D[1];
  var z = tx3D[2];
  var w = tx3D[3];

  /* General form
  tx3D[0] = (x * rotZm[ 0]) + (y * rotZm[ 4]) + (z * rotZm[ 8]) + (w * rotZm[12]);
  tx3D[1] = (x * rotZm[ 1]) + (y * rotZm[ 5]) + (z * rotZm[ 9]) + (w * rotZm[13]);
  tx3D[2] = (x * rotZm[ 2]) + (y * rotZm[ 6]) + (z * rotZm[10]) + (w * rotZm[14]);
  tx3D[3] = (x * rotZm[ 3]) + (y * rotZm[ 7]) + (z * rotZm[11]) + (w * rotZm[15]);
  */

  // Optimized form: multiply just the nonzero parts of setRotateAboutZAxis
  tx3D[0] = (x * rotZm[ 0]) + (y * rotZm[ 4])                                    ;
  tx3D[1] = (x * rotZm[ 1]) + (y * rotZm[ 5])                                    ;
  tx3D[2] =                                      z                               ;
  tx3D[3] =                                                        w             ;
}

export function render3D(index,x,y,z) {
  // x,y,z are in range from 0 to 1. Upscale them to range -1 to 1.
  // This moves (0,0,0) to the center of the volume.
  tx3D[0] = x*2.0-1.0
  tx3D[1] = y*2.0-1.0
  tx3D[2] = z*2.0-1.0
  tx3D[3] = 1

  rotateAboutZ()
  rotateAboutY()

  // Rendering based on Z axis in transformed space
  txZ = tx3D[2]
  if (txZ > 0) {
    // Colorful multilayered liquid in the bottom of container
    hsv(txZ*0.6,1,1)
  } else {
    // Fades to dark as we get further above surface of liquid
    hsv(0.01,1,1+txZ)
  }
}
