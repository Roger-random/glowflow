// Accelerometer value will be filled in by Pixelblaze when sensor board
// is present
export var accelerometer

// Unit accelerometer vector
var unitvect = array(3)

// Tilt from Z axis in radians. 0 = sitting flat, Pi = upside down.
var tiltZ

// For each rendering frame, take an accelerometer reading and generate
// unit vector for direction. From that, calculate tilt off Z.
export function beforeRender(delta) {
  // Take snapshot of accelerometer
  a = accelerometer

  // Adjust axis to fit mechanical chassis
  a[0] = -a[0] // X axis is mounted reversed

  // Calculate unit vector
  len = sqrt(pow(a[0],2) + pow(a[1],2) + pow(a[2],2) )

  for (i = 0; i < 3; i++) {
    unitvect[i] = a[i]/len
  }

  // Calculate tilt off of Z axis
  // Comment this out until PB bug fixed tiltZ = acos(unitvect[2])
}

function clipRad(original) {
  clipped = original
  while (clipped < 0) {
    clipped = clipped + 2*PI
  }
  while (clipped > 2*PI) {
    clipped = clipped - 2*PI
  }
  return clipped
}

export function render3D(index,x,y,z) {
  // x,y,z are in range from 0 to 1. Upscale them to range -1 to 1.
  // This moves (0,0,0) to the center of the volume.
  localX = x*2.0-1.0
  localY = y*2.0-1.0
  localZ = z*2.0-1.0

  // Convert from cartesian to spherical coordinates
  // Formula from https://en.wikipedia.org/wiki/List_of_common_coordinate_transformations#From_Cartesian_coordinates_2
  radius = sqrt(pow(localX,2) + pow(localY,2) + pow(localZ,2))
  polarAng = atan2(sqrt(pow(localX,2)+pow(localY,2))/localZ)
  azimuthAng = atan(localY/localX)

  hue = 0.01

  probe = azimuthAng/PI

  if (probe > 1) {
    hsv(probe, 1, wave(time(0.005)))
  } else if (probe > 0) {
    hsv(probe, 1, 0.1)
  } else {
    hsv(probe, wave(time(0.005)),0.1)
  }
}
