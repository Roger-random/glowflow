// Accelerometer value will be filled in by Pixelblaze when sensor board
// is present
export var accelerometer

// Tilt of accelerometer vector in spherical coordinates.
var accelPolar

// Direction of accelerometer vector in spherical coordinates
var accelAzimuth

// Matrix for transform calculations
var m = array(16)

// Coordinate for matrix transform calculations
var tx3D = array(4)

// For each rendering frame, take an accelerometer reading and generate
// unit vector for direction. From that, calculate tilt off Z.
export function beforeRender(delta) {
  // Take snapshot of accelerometer
  a = accelerometer

  // Adjust axis to fit mechanical chassis
  a[0] = -a[0] // X axis is mounted reversed

  // Calculate polar and azimuth angles
  accelPolar = atan(sqrt(pow(a[0],2)+pow(a[1],2))/a[2])
  if (a[0] == 0) {
    if (a[1] >= 0) {
      accelAzimuth = PI/2
    } else {
      accelAzimuth = 3*PI/2
    }
  } else if (a[0] > 0) {
    accelAzimuth = atan(a[1]/a[0])
  } else {
    accelAzimuth = PI-atan(a[1]/-a[0])
  }

  // Set transform matrix to identity
  setIdentity()
}

// 3D transform matrix math adapted from
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web
function setIdentity() {
  m[0]  = 1;  m[1]  = 0;  m[2]  = 0;  m[3]  = 0
  m[4]  = 0;  m[5]  = 1;  m[6]  = 0;  m[7]  = 0
  m[8]  = 0;  m[9]  = 0;  m[10] = 1;  m[11] = 0
  m[12] = 0;  m[13] = 0;  m[14] = 0;  m[15] = 1
}

function setRotateYAxis(angle) {
  /* General form
  m[0]=cos(angle); m[1]  = 0;  m[2]=sin(angle); m[3]  = 0
  m[4]  = 0;       m[5]  = 1;  m[6]  = 0;       m[7]  = 0
  m[8]=-sin(angle);m[9]  = 0;  m[10]=cos(angle);m[11] = 0
  m[12] = 0;       m[13] = 0;  m[14] = 0;       m[15] = 1
  */

  // Optimized for this specific application removing terms that don't change
  m[0]=cos(angle); m[1]  = 0;  m[2]=sin(angle)
  m[4]  = 0;       m[5]  = 1
  m[8]=-sin(angle);            m[10]=cos(angle)
}

function setRotateZAxis(angle) {
  /* General form
  m[0]=cos(angle);m[1]=-sin(angle);m[2]  = 0;  m[3]  = 0
  m[4]=sin(angle);m[5]=cos(angle); m[6]  = 0;  m[7]  = 0
  m[8]  = 0;      m[9]  = 0;       m[10] = 1;  m[11] = 0
  m[12] = 0;      m[13] = 0;       m[14] = 0;  m[15] = 1
  */

  // Optimized for this specific application removing terms that don't change
  m[0]=cos(angle);m[1]=-sin(angle);m[2]  = 0
  m[4]=sin(angle);m[5]=cos(angle)
  m[8]  = 0;                       m[10] = 1
}

function matrixMultiply() {
  // Make a copy of point coordinates
  var x = tx3D[0];
  var y = tx3D[1];
  var z = tx3D[2];
  var w = tx3D[3];

  /* general form
  tx3D[0] = (x * m[ 0]) + (y * m[ 4]) + (z * m[ 8]) + (w * m[12]);
  tx3D[1] = (x * m[ 1]) + (y * m[ 5]) + (z * m[ 9]) + (w * m[13]);
  tx3D[2] = (x * m[ 2]) + (y * m[ 6]) + (z * m[10]) + (w * m[14]);
  tx3D[3] = (x * m[ 3]) + (y * m[ 7]) + (z * m[11]) + (w * m[15]);
  */

  // Optimized for this specific application. Terms that are
  // always zero for us are removed.
  tx3D[0] = (x * m[ 0]) + (y * m[ 4]) + (z * m[ 8])              ;
  tx3D[1] = (x * m[ 1]) + (y * m[ 5])                            ;
  tx3D[2] = (x * m[ 2])               + (z * m[10])              ;
  tx3D[3] =                                           w          ;
}

export function render3D(index,x,y,z) {
  // x,y,z are in range from 0 to 1. Upscale them to range -1 to 1.
  // This moves (0,0,0) to the center of the volume.
  localX = x*2.0-1.0
  localY = y*2.0-1.0
  localZ = z*2.0-1.0

  tx3D[0] = localX
  tx3D[1] = localY
  tx3D[2] = localZ
  tx3D[3] = 1

  setRotateZAxis(accelAzimuth)
  matrixMultiply()

  setRotateYAxis(accelPolar)
  matrixMultiply()

  probe = tx3D[2]

  if (probe < 0) {
    hsv(0.01,1,0.1)
  }
}
